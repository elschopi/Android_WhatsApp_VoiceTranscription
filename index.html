<!DOCTYPE html>
<html lang="de" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="docTitle">WhatsApp Transcriber</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <style>
        html { scroll-behavior: smooth; }
        .htmx-request .htmx-indicator { opacity: 1; }
        .htmx-indicator { opacity: 0; transition: opacity 200ms ease-in; }
        .message-card.selected {
            border-color: #10b981;
            background-color: #1f2937;
            transform: scale(1.02);
        }
        .provider-unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>
</head>
<body class="bg-gray-900 text-gray-300 font-sans leading-normal tracking-tight p-4 md:p-8">
    <div class="max-w-2xl mx-auto">
        <!-- TITEL -->
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-white mb-1" data-i18n="header">WhatsApp Transcriber</h1>
            <p class="text-lg text-gray-400" data-i18n="subHeader">Sprachnachrichten finden und transkribieren</p>
        </header>

        <!-- BEDIENFELD -->
        <div class="bg-gray-800/80 backdrop-blur-sm p-4 rounded-xl shadow-lg mb-6 sticky top-4 z-10 border border-gray-700">
            <div class="grid grid-cols-3 gap-3 mb-4">
                <!-- Nachrichten suchen Button -->
                <button id="search-btn"
                    class="col-span-3 sm:col-span-1 flex items-center justify-center gap-2 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition-all duration-200 h-full"
                    hx-get="/api/messages" 
                    hx-target="#message-list" 
                    hx-swap="innerHTML"
                    hx-indicator="#loading-indicator">
                    <svg class="htmx-indicator h-5 w-5 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span id="search-btn-text" data-i18n="searchButton">Nachrichten suchen</span>
                </button>
                <!-- 'Alle' Button -->
                <button id="select-all-btn" data-i18n="selectAllButton"
                    class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-3 px-4 rounded-lg transition-all duration-200">
                    Alle
                </button>
                <!-- 'Keine' Button -->
                <button id="deselect-all-btn" data-i18n="selectNoneButton"
                    class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-3 px-4 rounded-lg transition-all duration-200">
                    Keine
                </button>
            </div>

            <!-- Provider Auswahl -->
            <div class="mb-3 flex items-center justify-between gap-3 bg-gray-700/50 p-2 rounded-lg border border-gray-600">
                <label for="provider-select" class="text-sm text-gray-300 font-medium pl-1">
                    <span data-i18n="providerLabel">Provider:</span>
                </label>
                <select id="provider-select" 
                    class="bg-gray-600 text-white text-sm rounded-md px-3 py-1.5 border border-gray-500 focus:ring-emerald-500 focus:border-emerald-500 block">
                    <option value="groq" data-i18n-option="providerGroq">Groq (Whisper API)</option>
                    <option value="local" data-i18n-option="providerLocal">Local Whisper (large-v3)</option>
                    <option value="gemini" data-i18n-option="providerGemini">Gemini</option>
                </select>
            </div>

            <!-- Provider Status Anzeige -->
            <div id="provider-status" class="mb-3 text-xs text-gray-400 px-2 hidden">
                <span data-i18n="providerStatusLoading">Prüfe Provider-Verfügbarkeit...</span>
            </div>

            <!-- Transkribieren Button -->
            <button id="transcribe-btn"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-5 rounded-lg shadow-lg transition-all duration-200 flex items-center justify-center gap-2"
                disabled>
                <span id="transcribe-btn-text" data-i18n="transcribeButtonDefault">Wähle Nachrichten zum Transkribieren</span>
                <svg id="transcribe-spinner" class="h-5 w-5 animate-spin hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </button>
        </div>

        <!-- NACHRICHTENLISTE -->
        <main>
            <h2 class="text-2xl font-semibold text-white mb-4" data-i18n="foundMessages">Gefundene Nachrichten</h2>
            <div id="loading-indicator" class="htmx-indicator text-center p-4">
                <p class="text-gray-400" data-i18n="searching">Suche nach Nachrichten...</p>
            </div>
            <div id="message-list" class="grid grid-cols-1 gap-4">
                <p class="text-gray-500" data-i18n="searchPlaceholder">Klicke "Nachrichten suchen", um zu starten.</p>
            </div>
        </main>

        <!-- GLOBALES STATUS-FENSTER -->
        <div id="status-container" class="mt-8">
            <h3 class="text-xl font-semibold text-white mb-3" data-i18n="logHeader">Log</h3>
            <div id="status-log" class="h-48 p-4 bg-gray-800 rounded-lg shadow-inner overflow-y-auto font-mono text-sm text-gray-400 border border-gray-700">
                <p data-i18n="logReady">Bereit. Warte auf Aktion.</p>
            </div>
        </div>
    </div>

    <script>
        // --- Internationalisierung (i18n) ---
        const translations = {
            "en": {
                "docTitle": "WhatsApp Transcriber",
                "header": "WhatsApp Transcriber",
                "subHeader": "Find and transcribe voice notes",
                "searchButton": "Find Messages",
                "searching": "Searching for messages...",
                "searchPlaceholder": "Click \"Find Messages\" to start.",
                "selectAllButton": "All",
                "selectNoneButton": "None",
                "transcribeButtonDefault": "Select messages to transcribe",
                "transcribeButtonCount": (count) => `Transcribe ${count} message${count > 1 ? 's' : ''}`,
                "processing": (current, total) => `Processing ${current}/${total}...`,
                "transcribing": "Transcribing...",
                "foundMessages": "Found Messages",
                "logHeader": "Log",
                "logReady": "Ready. Waiting for action.",
                "logSearchStarted": "Searching for WhatsApp voice notes...",
                "logSearchFailed": "Failed to load messages.",
                "logSearchSuccess": "Message list loaded successfully.",
                "logStart": (count) => `Starting transcription for ${count} message(s)...`,
                "logSuccess": (name) => `Transcription for ${name} successful.`,
                "logFailed": (name, error) => `Failed on ${name}: ${error}`,
                "logComplete": (success, total) => `Transcription complete. ${success}/${total} successful.`,
                "logRefresh": "Refreshing message list...",
                "logErrorNoMessages": "No messages selected for transcription.",
                "errorFolderNotFound": "WhatsApp folder not found.",
                "errorNoOpusFiles": "No .opus files found in folder.",
                "errorNoMessagesFound": "No messages found or error during processing.",
                "timeUnit": " ",
                "waitingForTranscription": "Waiting for transcription...",
                "providerLabel": "AI Provider:",
                "providerGroq": "Groq (Whisper API)",
                "providerLocal": "Local Whisper (large-v3)",
                "providerGemini": "Gemini",
                "providerStatusLoading": "Checking provider availability...",
                "providerUnavailable": (provider) => `${provider} is not available`,
                "providerLocalInfo": "Local Whisper provides best accuracy for German (10-20s per message)"
            },
            "de": {
                "docTitle": "WhatsApp Transkribierer",
                "header": "WhatsApp Transcriber",
                "subHeader": "Sprachnachrichten finden und transkribieren",
                "searchButton": "Nachrichten suchen",
                "searching": "Suche nach Nachrichten...",
                "searchPlaceholder": "Klicke \"Nachrichten suchen\", um zu starten.",
                "selectAllButton": "Alle",
                "selectNoneButton": "Keine",
                "transcribeButtonDefault": "Wähle Nachrichten zum Transkribieren",
                "transcribeButtonCount": (count) => `${count} Nachricht${count > 1 ? 'en' : ''} transkribieren`,
                "processing": (current, total) => `Verarbeite ${current}/${total}...`,
                "transcribing": "Transkribiere...",
                "foundMessages": "Gefundene Nachrichten",
                "logHeader": "Log",
                "logReady": "Bereit. Warte auf Aktion.",
                "logSearchStarted": "Suche nach WhatsApp-Sprachnachrichten...",
                "logSearchFailed": "Fehler beim Laden der Nachrichten.",
                "logSearchSuccess": "Nachrichtenliste erfolgreich geladen.",
                "logStart": (count) => `Starte Transkription für ${count} Nachricht(en)...`,
                "logSuccess": (name) => `Transkription für ${name} erfolgreich.`,
                "logFailed": (name, error) => `Fehler bei ${name}: ${error}`,
                "logComplete": (success, total) => `Transkription abgeschlossen. ${success}/${total} erfolgreich.`,
                "logRefresh": "Lade Nachrichtenliste neu...",
                "logErrorNoMessages": "Keine Nachrichten zum Transkribieren ausgewählt.",
                "errorFolderNotFound": "WhatsApp-Ordner nicht gefunden.",
                "errorNoOpusFiles": "Keine .opus-Dateien im Ordner gefunden.",
                "errorNoMessagesFound": "Keine Nachrichten gefunden oder Fehler beim Verarbeiten.",
                "timeUnit": " Uhr",
                "waitingForTranscription": "Warte auf Transkription...",
                "providerLabel": "Anbieter:",
                "providerGroq": "Groq (Whisper API)",
                "providerLocal": "Lokales Whisper (large-v3)",
                "providerGemini": "Gemini",
                "providerStatusLoading": "Prüfe Provider-Verfügbarkeit...",
                "providerUnavailable": (provider) => `${provider} ist nicht verfügbar`,
                "providerLocalInfo": "Lokales Whisper bietet beste Genauigkeit für Deutsch (10-20s pro Nachricht)"
            }
        };

        let currentLanguage = 'en'; 
        let T = translations[currentLanguage];
        let providerStatus = {
            groq: false,
            gemini: false,
            local: false
        };

        function setLanguage(lang) {
            currentLanguage = lang;
            T = translations[currentLanguage];
            document.documentElement.lang = currentLanguage;

            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                if (T[key] && typeof T[key] === 'string') {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.placeholder = T[key];
                    } else {
                        el.textContent = T[key];
                    }
                }
            });

            document.querySelectorAll('[data-i18n-option]').forEach(el => {
                const key = el.dataset.i18nOption;
                if (T[key]) {
                    el.textContent = T[key];
                }
            });

            document.querySelectorAll('[data-i18n="timeUnit"]').forEach(el => el.textContent = T.timeUnit);
            document.querySelectorAll('[data-i18n="waitingForTranscription"]').forEach(el => el.textContent = T.waitingForTranscription);
            document.querySelectorAll('[data-i18n="errorFolderNotFound"]').forEach(el => el.textContent = T.errorFolderNotFound);
            document.querySelectorAll('[data-i18n="errorNoOpusFiles"]').forEach(el => el.textContent = T.errorNoOpusFiles);
            document.querySelectorAll('[data-i18n="errorNoMessagesFound"]').forEach(el => el.textContent = T.errorNoMessagesFound);
        }

        function detectLanguage() {
            const userLang = navigator.language || navigator.userLanguage; 
            if (userLang && userLang.startsWith('de')) {
                setLanguage('de');
            } else {
                setLanguage('en');
            }
        }

        async function checkProviderStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();
                providerStatus = {
                    groq: status.groq_available,
                    gemini: status.gemini_available,
                    local: status.local_whisper_available
                };

                updateProviderSelect();

                const statusDiv = document.getElementById('provider-status');
                const unavailable = [];
                if (!providerStatus.groq) unavailable.push('Groq');
                if (!providerStatus.gemini) unavailable.push('Gemini');
                if (!providerStatus.local) unavailable.push('Local Whisper');

                if (unavailable.length > 0) {
                    statusDiv.textContent = T.providerUnavailable(unavailable.join(', '));
                    statusDiv.classList.remove('hidden');
                } else {
                    statusDiv.classList.add('hidden');
                }

                log(`Provider Status: Groq=${providerStatus.groq}, Gemini=${providerStatus.gemini}, Local=${providerStatus.local}`, 'info');
            } catch (error) {
                log(`Fehler beim Prüfen der Provider: ${error.message}`, 'error');
            }
        }

        function updateProviderSelect() {
            const select = document.getElementById('provider-select');
            const options = select.querySelectorAll('option');

            options.forEach(option => {
                const provider = option.value;
                if (!providerStatus[provider]) {
                    option.disabled = true;
                    option.textContent += ' (nicht verfügbar)';
                    option.classList.add('provider-unavailable');
                }
            });

            const currentValue = select.value;
            if (!providerStatus[currentValue]) {
                if (providerStatus.local) {
                    select.value = 'local';
                } else if (providerStatus.groq) {
                    select.value = 'groq';
                } else if (providerStatus.gemini) {
                    select.value = 'gemini';
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            detectLanguage();
            checkProviderStatus();

            const messageList = document.getElementById('message-list');
            const transcribeBtn = document.getElementById('transcribe-btn');
            const transcribeBtnText = document.getElementById('transcribe-btn-text');
            const transcribeSpinner = document.getElementById('transcribe-spinner');
            const selectAllBtn = document.getElementById('select-all-btn');
            const deselectAllBtn = document.getElementById('deselect-all-btn');
            const statusLog = document.getElementById('status-log');
            const providerSelect = document.getElementById('provider-select');

            let isTranscribing = false;

            function log(message, type = 'info') {
                const p = document.createElement('p');
                let prefix = '[INFO]';
                if (type === 'error') {
                    p.className = 'text-red-400';
                    prefix = '[ERROR]';
                } else if (type === 'success') {
                    p.className = 'text-emerald-400';
                    prefix = '[OK]';
                }
                p.textContent = `${prefix} ${message}`;
                statusLog.appendChild(p);
                statusLog.scrollTop = statusLog.scrollHeight;
            }

            function updateTranscribeButton() {
                if (isTranscribing) return;

                const selectedCount = messageList.querySelectorAll('.message-checkbox:checked').length;
                if (selectedCount > 0) {
                    transcribeBtn.disabled = false;
                    transcribeBtnText.textContent = T.transcribeButtonCount(selectedCount);
                } else {
                    transcribeBtn.disabled = true;
                    transcribeBtnText.textContent = T.transcribeButtonDefault;
                }
            }

            messageList.addEventListener('click', (e) => {
                const card = e.target.closest('.message-card');
                if (!card) return;
                const checkbox = card.querySelector('.message-checkbox');
                if (!checkbox) return;
                if (!e.target.closest('audio')) {
                    checkbox.checked = !checkbox.checked;
                }
                if (checkbox.checked) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
                updateTranscribeButton();
            });

            selectAllBtn.addEventListener('click', () => {
                messageList.querySelectorAll('.message-checkbox').forEach(cb => {
                    cb.checked = true;
                    cb.closest('.message-card')?.classList.add('selected');
                });
                updateTranscribeButton();
            });

            deselectAllBtn.addEventListener('click', () => {
                messageList.querySelectorAll('.message-checkbox').forEach(cb => {
                    cb.checked = false;
                    cb.closest('.message-card')?.classList.remove('selected');
                });
                updateTranscribeButton();
            });

            providerSelect.addEventListener('change', () => {
                if (providerSelect.value === 'local') {
                    log(T.providerLocalInfo, 'info');
                }
            });

            transcribeBtn.addEventListener('click', async () => {
                if (isTranscribing) return;

                const selectedCheckboxes = Array.from(messageList.querySelectorAll('.message-checkbox:checked'));
                const pathsToTranscribe = selectedCheckboxes.map(cb => cb.dataset.path);

                if (pathsToTranscribe.length === 0) {
                    log(T.logErrorNoMessages, 'error');
                    return;
                }

                const selectedProvider = providerSelect.value;
                if (!providerStatus[selectedProvider]) {
                    log(`Provider ${selectedProvider} ist nicht verfügbar!`, 'error');
                    return;
                }

                isTranscribing = true;
                transcribeBtn.disabled = true;
                transcribeSpinner.classList.remove('hidden');
                log(T.logStart(pathsToTranscribe.length) + ` (Provider: ${selectedProvider})`);

                let successCount = 0;
                for (let i = 0; i < pathsToTranscribe.length; i++) {
                    const path = pathsToTranscribe[i];
                    const card = messageList.querySelector(`.message-card[data-path="${path}"]`);
                    const outputDiv = card.querySelector('.transcription-output');
                    const checkbox = card.querySelector('.message-checkbox');

                    transcribeBtnText.textContent = T.processing(i + 1, pathsToTranscribe.length);
                    outputDiv.classList.remove('hidden');
                    outputDiv.textContent = T.transcribing;

                    try {
                        const response = await fetch('/api/transcribe', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                path: path, 
                                lang: currentLanguage,
                                provider: selectedProvider
                            })
                        });

                        const result = await response.json();

                        if (!response.ok) {
                            throw new Error(result.error || 'Unknown server error');
                        }

                        outputDiv.textContent = result.transcription;
                        outputDiv.classList.remove('italic');
                        log(T.logSuccess(Path.basename(path)), 'success');
                        card.classList.remove('selected');
                        card.classList.add('opacity-50');
                        checkbox.disabled = true;
                        checkbox.checked = false;
                        successCount++;

                    } catch (error) {
                        log(T.logFailed(Path.basename(path), error.message), 'error');
                        outputDiv.textContent = `Error: ${error.message}`;
                        outputDiv.classList.add('text-red-400');
                    }
                }

                log(T.logComplete(successCount, pathsToTranscribe.length), 'success');
                isTranscribing = false;
                transcribeSpinner.classList.add('hidden');
                updateTranscribeButton();

                log(T.logRefresh);
                htmx.trigger('#search-btn', 'click');
            });

            const Path = {
                basename: (path) => path.split(/[\\/]/).pop()
            };

            htmx.on(document.body, 'htmx:beforeRequest', function(evt) {
                if (evt.detail.elt.id === 'search-btn') {
                    document.getElementById('search-btn-text').textContent = T.searching;
                    log(T.logSearchStarted);
                }
            });

            htmx.on(document.body, 'htmx:afterRequest', function(evt) {
                if (evt.detail.elt.id === 'search-btn') {
                    setLanguage(currentLanguage);
                    document.getElementById('search-btn-text').textContent = T.searchButton;
                    if (evt.detail.failed) {
                        log(T.logSearchFailed, 'error');
                        messageList.innerHTML = `<p class="text-red-400">${T.logSearchFailed}</p>`;
                    } else {
                        log(T.logSearchSuccess, 'success');
                    }
                }
            });
        });
    </script>
</body>
</html>
